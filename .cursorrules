# Cursor Rules - 新人フルスタック開発者向け規約

## 🎯 このルールの目的
- 分からないことは放置しない → **質問 → 理解 → 実装**
- AI生成コードと人間の成果物を**明確に分離**する
- 進捗は**Gitで見える化**し、作業証跡を残す

## 🖥️ 環境
- **ターミナル：Git Bash（Windows）**
- Git Bashはbash互換のため、`&&` や `-m` オプションで日本語が使える

---

## ⚠️ 開発開始前の必須確認

**コードを1行でも書く前に、必ず以下を確認すること：**

### 1. GitHubリポジトリのURL
```
「GitHubリポジトリのURLを教えてください」
「このプロジェクトのリモートリポジトリはありますか？」
```
→ **URLがない場合は開発を開始しない**（先にリポジトリを作成してもらう）

### 2. 曖昧な指示は質問する
→ 目的・入力・出力・エラー処理が不明確なら、必ず質問してから実装

---

## ⚠️ AIの行動ルール

### 基本原則
**指示されたことだけを実行する。先回りして勝手に作らない。**

### ❌ やってはいけないこと
- 要望を聞いて勝手に要件定義書を作る
- 要件定義を聞いて勝手に基本設計書を作る
- 頼まれていないファイルを勝手に作成する
- 「ついでに○○も作っておきました」

### ✅ やるべきこと
- 次のステップを**提案**する（実行はしない）
- 承認を得てから実行する
- 不明点は質問する

### ✅ 必ずやること（コード生成時）
1. **すべてのファイルにコメントを残す**
   - 関数・クラスの目的
   - 重要な処理の説明
   - 新人が読んで理解できるレベルで

2. **新人向けに解説しながら進める**
   - 「なぜこう書くのか」を説明する
   - 専門用語は補足を添える
   - 処理の流れを分かりやすく伝える

3. **指示が不十分なら必ず質問→フィードバック**
   - 曖昧な点は実装前に質問する
   - 質問後、「こう書けば伝わった」を必ずフィードバックする
   - フィードバックテンプレートを使う（7章参照）

### 提案の例
```
❌ NG：「要件定義書を作成しました」（勝手に作る）
✅ OK：「要件定義書を作成しましょうか？」（提案して確認）

❌ NG：「基本設計書も一緒に作りました」（先回り）
✅ OK：「次は基本設計書を作成する流れになりますが、進めますか？」（提案）
```

### なぜこのルール？
- **新人が自分で考える機会を奪わない**
- 新人がプロンプトで指示を出す練習になる
- 作業の流れを新人自身が理解できる

---

## 1. 命名規則

### 共通ルール
- **意味のある英語名**をつける（略語・ローマ字禁止）
- **一貫性**を保つ（プロジェクト内で統一）

### 言語別ルール

| 対象 | TypeScript/JS | Python | C#/Java |
|------|---------------|--------|---------|
| ファイル名 | kebab-case | snake_case | PascalCase |
| 変数 | camelCase | snake_case | camelCase |
| 関数 | camelCase | snake_case | PascalCase(C#) / camelCase(Java) |
| クラス | PascalCase | PascalCase | PascalCase |
| 定数 | UPPER_SNAKE_CASE | UPPER_SNAKE_CASE | UPPER_SNAKE_CASE |

### 共通命名ルール

| 対象 | ルール | 例 |
|------|--------|-----|
| DBテーブル | snake_case（複数形） | `users`, `order_items` |
| APIエンドポイント | kebab-case（複数形） | `/api/users`, `/api/order-items` |
| 環境変数 | UPPER_SNAKE_CASE | `DATABASE_URL` |
| Gitブランチ | kebab-case | `feature/user-auth` |

### ❌ NG例
```
data, info, temp, hoge, foo  → 意味がない
flg, btn, msg                → 略しすぎ
torokuUser, loginKakunin    → ローマ字禁止
user_Service                 → ケース混在
```

---

## 2. コメント方針

### 書く場所
1. **関数の直前** - 目的・引数・戻り値
2. **複雑なロジック** - なぜ必要か
3. **正規表現** - パターンの意味
4. **マジックナンバー** - 数値の意味

### 書き方
```typescript
// ✅ GOOD：理由を書く
// 18歳未満は保護者同意が必要なためエラーを返す
if (user.age < 18) { ... }

// ❌ BAD：見れば分かることを書かない
// ageが18より小さいかチェック
if (user.age < 18) { ... }
```

### ❌ NGコメント
- コードを読めば分かる内容
- コードと矛盾する古いコメント
- 3行以上の長文

---

## 3. ドキュメント方針

### 作成タイミング
1. **要件定義書** → プロジェクト開始時（何を作るか）
2. **基本設計書** → 要件定義後（どう作るか + ディレクトリ構成確定）
3. **詳細設計書** → 基本設計後（機能ごとに必要な時）

### 配置場所
```
docs/
├── requirements.md      # 要件定義書
├── basic-design.md      # 基本設計書
└── detailed-design/     # 詳細設計書（機能別）
```

### 必須ルール
- 各項目に「**なぜ必要か**」を新人向けに記載する
- 最低限の項目でOK、薄くても作る

---

## 4. ディレクトリ構成のルール

### 確定タイミング
**基本設計書を作成する段階で確定**

### 変更したい場合
1. 基本設計書の「ディレクトリ構成」を更新
2. 変更理由を記載
3. 影響範囲を確認
4. レビュー/合意を得る

---

## 5. Git運用

### ⚠️ プロジェクト開始前（必須）
**コードを書く前に、必ずGitHubリポジトリのURLを確認する**

```
質問例：
「GitHubリポジトリのURLを教えてください」
「このプロジェクトのリモートリポジトリはありますか？」
```

→ **URLがない場合は開発を開始しない**（先にリポジトリを作成してもらう）

### 既存プロジェクトにCursor Rulesを追加した場合
**AIは以下を自動で実行すること：**
1. `git remote -v` でリモート確認
2. リモートがなければ → ユーザーにURLを聞く
3. `git fetch origin` でリモートの情報を取得
4. `ai-generated`ブランチがなければ作成

```bash
# リモート確認
git remote -v

# リモートの最新情報を取得
git fetch origin

# ai-generatedブランチ作成（既存プロジェクト対応）
git checkout -b ai-generated
# または既にリモートにある場合
git checkout -b ai-generated origin/ai-generated
```

### ブランチ構成
```
main (または master)  # 人間が確認・承認したコード
ai-generated          # AIで生成したコード（自動プッシュ先）
feature/xxx           # 機能開発
fix/xxx               # バグ修正
```

### ⚠️ プッシュ先のルール（重要）

| 実行者 | プッシュ先 | 条件 |
|--------|-----------|------|
| **AI（自動）** | `ai-generated` | コード・ドキュメントの追加/修正/変更時は**必ず**プッシュ |
| **人（依頼）** | `main` または `master` | 人が「プッシュして」と依頼した場合のみ |

### ⚠️ AIが作業する前（必須・自動実行）
**mainブランチでは作業しない。必ずai-generatedブランチで作業する。**

**AIは以下を自動で実行すること：**
1. `git branch` で現在のブランチを確認
2. main/masterブランチにいる場合 → `ai-generated`に切り替え
3. ai-generatedブランチにいることを確認してから作業開始

```bash
# 1. 現在のブランチを確認
git branch

# 2. ai-generatedブランチに切り替え（なければ作成）
git checkout ai-generated 2>/dev/null || git checkout -b ai-generated

# 3. ブランチ確認後、作業を開始
```

→ **この手順をスキップして作業してはいけない**

### ⚠️ AIが作業した後（必須・自動実行）
**ソースコード・ドキュメントの追加/修正/変更があったら、AIは必ず以下を実行すること：**

```bash
# 1. 変更をステージング
git add .

# 2. コミット
git commit -m "feat(ai): 機能を生成"

# 3. ai-generatedブランチにプッシュ（必須）
git push origin ai-generated
```

→ **変更があったら必ずプッシュする（スキップ禁止）**

### ⚠️ 人がプッシュを依頼した場合
**「プッシュして」「mainにあげて」等の依頼があった場合のみ、main/masterにプッシュ**

```bash
# mainブランチに切り替え
git checkout main
# または
git checkout master

# ai-generatedの内容をマージ
git merge ai-generated

# mainにプッシュ
git push origin main
# または
git push origin master
```

### コミットメッセージ
```
<type>: <summary>

type:
- feat     : 新機能
- fix      : バグ修正
- docs     : ドキュメント
- refactor : リファクタリング
- test     : テスト
- chore    : 設定変更

例:
feat: ログイン機能を実装
fix: ユーザー取得時のnullエラーを修正
feat(ai): 商品一覧APIを生成
```

### mainブランチへのコミット条件
- **人間がレビュー・承認したコードのみ**
- AIが直接mainにコミット/プッシュしない
- マージは人間の判断で行う

---

## 6. 質問の義務

### 基本ルール
**曖昧な指示は実装前に必ず質問する**

### 質問チェックリスト
| 項目 | 確認内容 |
|------|----------|
| 目的 | この機能は何を達成するのか？ |
| 入力 | 何を受け取るのか？ |
| 出力 | 何を返すのか？ |
| エラー | エラー時の動作は？ |
| 例 | 具体的なサンプルデータは？ |
| 完了条件 | 何をもって完了か？ |

### 質問テンプレート
```
## 質問
○○について確認させてください。

### 現在の理解
- △△という認識であっていますか？

### 確認したいこと
1. □□の場合の動作はどうなりますか？

### 自分の仮説
不明な場合、◇◇として実装しますが問題ないですか？
```

---

## 7. プロンプト改善フィードバック

### 基本ルール
- 指示が曖昧・抽象的なら**必ず質問する**
- 質問後、「**こう書けば伝わった**」を具体例で必ずフィードバックする
- フィードバックは**責めない**、**型（テンプレ）で返す**

### いつフィードバックするか
| 状況 | 対応 |
|------|------|
| 目的が不明 | 「何を達成したいですか？」と質問 |
| 入力/出力が曖昧 | 「具体的なデータ例を教えてください」と質問 |
| 複数の解釈ができる | 「AとBどちらの意味ですか？」と質問 |
| エラー処理が不明 | 「エラー時はどうしますか？」と質問 |

### フィードバックテンプレート（必ずこの形式で返す）
```
## 📝 プロンプト改善フィードバック

### 元の指示
「○○を作って」

### 不足していた情報
- 目的が不明確
- 入力データの形式が不明
- エラー時の動作が未定義

### 改善例（次回はこう書くと伝わりやすい）
「○○を作ってください。
- 目的：△△のため
- 入力：{ name: "田中", age: 20 }
- 出力：{ success: true, data: {...} }
- エラー時：{ success: false, error: "メッセージ" }
- 完了条件：□□ができたらOK」

### ポイント
- 具体的なデータ例があると実装が速くなります
- エラーパターンを先に伝えると手戻りが減ります
```

### フィードバック時の注意
| ❌ NG | ✅ OK |
|-------|-------|
| 「分かりません」 | 「こう書くと伝わりやすいです」 |
| 「曖昧です」 | 「具体例：○○のように書くと明確です」 |
| 責める口調 | 提案する口調 |
| 抽象的なアドバイス | 具体的な改善例 |

### なぜフィードバックが重要？
- **新人がプロンプトの書き方を学べる**
- 次回から同じ質問が不要になる
- 指示の出し方が上達する → 開発効率が上がる

---

## 8. 開発の流れ

### 基本的な開発フロー
```
1. 要件定義作成
    ↓
2. 基本設計・詳細設計作成
   （ディレクトリ構成、ファイル行数制限を設定）
    ↓
3. 環境構築
    ↓
4. フロントエンド開発（単体で動作確認）
    ↓
5. バックエンド開発（単体で動作確認）
    ↓
6. 結合・テスト
    ↓
7. レビュー
    ↓
8. 納品
```

### 開発前の確認（必須）
**要件定義書・基本設計書を確認し、ソースコードとのズレがないようにする**

### フロントエンド/バックエンドの分離
- **分けて開発**する
- **それぞれで動作テスト**できるようにする
- フロントエンド：モックデータで動作確認
- バックエンド：Postman/curl等でAPI単体確認

---

## 📋 毎日のチェックリスト

### 作業開始時
- [ ] `git remote -v` でリモート確認
- [ ] `git pull origin main` で最新取得
- [ ] 今日やることを把握

### コード生成前
- [ ] 要件定義書を確認したか？
- [ ] 基本設計書を確認したか？
- [ ] 目的を理解したか？
- [ ] 入力/出力は明確か？
- [ ] 不明点は質問したか？

### コミット前
- [ ] コードは動作するか？
- [ ] 命名規則に従っているか？
- [ ] 適切なブランチにいるか？

---

## 🔧 言語選定の目安

| 用途 | 推奨 |
|------|------|
| Webフルスタック | TypeScript |
| データ分析/ML | Python |
| エンタープライズ | C# / Java |
| 高パフォーマンス | Go / Rust |

**迷ったらTypeScript**（フロント・バック両方対応）

---

_最終更新: 2026-01-22_
